# Parking Core Service

Backend module for the Parking Management System.
Provides business logic for vehicle entries/exits, slots, tariffs, receipts and reports.
This service is designed to work together with:

* WEB UI (HTML/CSS/JS frontend)
* AUTH-SERVICE (Java, JWT provider) — kept separate by design

This README describes only the `core-service` module.

---

1. Features

---

* REST API built with FastAPI.
* Object-oriented design with clear layers (API → Service → Repository → Models).
* Follows SOLID principles to keep logic isolated and testable.
* Slot management:

  * List parking slots.
  * Track occupied vs free spaces.
* Vehicle sessions:

  * Register vehicle entry (assigns free slot).
  * Register vehicle exit (computes duration and total amount).
  * Prevent double-entry for the same active plate.
* Tariffs:

  * Configurable rate per minute.
  * Amount = minutes * rate_per_minute (with basic rounding rules).
* Reports:

  * Recent sessions listing.
  * Dashboard overview: occupied, free, active vehicles, current rate, occupancy%.
* Pagination / filters (can be extended).
* OpenAPI documentation auto-generated by FastAPI.
* Test suite with pytest:

  * Unit + integration-style tests using in-memory SQLite.
  * Dependency overrides for DB and auth.

---

2. Tech Stack

---

* Language: Python 3.11
* Framework: FastAPI
* ORM: SQLAlchemy
* Migrations: Alembic
* Database (prod): PostgreSQL
* Database (dev/demo): SQLite file
* Testing: pytest, httpx / TestClient
* Auth integration: JWT (validated via separate AUTH-SERVICE, optional for dev)

---

3. Project Structure

---

Inside the `core-service` folder:

* `alembic/` — database migrations
* `app/`

  * `__init__.py`
  * `main.py` — FastAPI app entrypoint
  * `config.py` — settings and environment configuration
  * `db.py` — engine, session factory, Base
  * `models.py` — SQLAlchemy models (slots, tariffs, parking_sessions, etc.)
  * `schemas.py` — Pydantic models (requests/responses)
  * `api/`

    * `__init__.py`
    * `deps.py` — shared dependencies (DB session, auth user)
    * `routes_health.py` — healthcheck endpoint
    * `routes_slots.py` — slot-related endpoints
    * `routes_parking.py` — entries, exits, sessions, overview
    * `routes_reports.py` — reporting endpoints (extension point)
  * `repositories/`

    * `__init__.py`
    * `slot_repository.py`
    * `parking_repository.py`
    * `tariff_repository.py`
  * `services/`

    * `__init__.py`
    * `auth_service.py` — JWT validation wrapper (uses AUTH-SERVICE when enabled)
    * `tariff_service.py`
    * `slot_service.py`
    * `parking_service.py` — core business logic (entries, exits, sessions, overview)
    * `report_service.py`
* `tests/`

  * `__init__.py`
  * `conftest.py` — test DB + dependency overrides
  * `test_parking.py`
  * `test_reports.py`
* `requirements.txt`
* `alembic.ini`

---

4. Configuration

---

The service uses environment variables (via `config.py`). Typical `.env`:

For local development with SQLite:

* `DATABASE_URL=sqlite:///./parking_dev.db`
* `API_PREFIX=/api/core`
* `DISABLE_AUTH=true`
* `JWT_SECRET=dev-secret`
* `JWT_ALGORITHM=HS256`
* `JWT_ISSUER=parking-auth-service`
* `BACKEND_CORS_ORIGINS=["http://localhost:8081"]`

For PostgreSQL (recommended for real deployments):

* `DATABASE_URL=postgresql://USER:PASSWORD@localhost:5432/parking_db`
* other variables same as above, adjust as needed.

Notes:

* `DISABLE_AUTH=true`

  * Auth is bypassed.
  * Ideal for local development and when AUTH-SERVICE is not running.
* `DISABLE_AUTH=false`

  * Requests must include a valid `Authorization: Bearer <jwt>` header.
  * JWT is validated according to `JWT_SECRET` / public key and `JWT_ISSUER`.
  * Integration is handled through `auth_service.py` (Java auth-service expected).

---

5. Setup & Run (Local Dev)

---

Prerequisites:

* Python 3.11
* pip
* (Optional) PostgreSQL if you want real DB instead of SQLite

Steps:

1. Navigate to the module:

   * `cd core-service`

2. Create and activate a virtual environment (optional but recommended).

3. Install dependencies:

   * `pip install -r requirements.txt`

4. Configure environment:

   * Create `.env` in `core-service/` with the variables from section 4.

5. Initialize the database schema:

   * For quick dev with SQLite:

     * `python -c "from app.db import Base, engine; Base.metadata.create_all(bind=engine)"`
   * Or, using Alembic (PostgreSQL or SQLite):

     * `alembic upgrade head`

6. Start the API server:

   * `uvicorn app.main:app --reload --port 8000`

7. Open API docs (auto):

   * Swagger UI: `http://localhost:8000/docs`
   * ReDoc: `http://localhost:8000/redoc`

The WEB UI should be configured to call:

* `http://localhost:8000/api/core/...`

---

6. Running Tests

---

Tests are self-contained and do not touch your real database.

From `core-service/`:

* `pytest -q`

How tests are wired:

* `tests/conftest.py`:

  * Creates an in-memory SQLite database using a shared `StaticPool`.
  * Runs `Base.metadata.create_all` once.
  * Before each test:

    * Cleans tables.
    * Seeds demo slots (`A01`, `A02`, `A03`) and a default tariff.
  * Overrides `get_db` dependency to use this test DB.
  * Overrides auth dependency to inject a fake user (no real JWT needed).
* Tests cover:

  * Health endpoint.
  * Entry creation and slot occupation.
  * Double-entry prevention.
  * Exit with amount calculation and slot freeing.
  * Sessions listing.
  * Stats overview consistency.

If tests are green, your core-service behavior is aligned with the expected workshop requirements.

---

7. API Overview

---

Base URL:

* `http://localhost:8000/api/core`

Main endpoints:

1. `GET /health`

   * Simple healthcheck.
   * Response: `{"status": "ok"}`

2. `GET /slots`

   * Returns all parking slots and their occupancy state.

3. `POST /entries`

   * Registers vehicle entry.
   * Request body:

     * `{ "plate": "ABC123" }`
   * Behavior:

     * Validates plate.
     * Ensures no active session already exists for that plate.
     * Assigns first free slot.
     * Persists parking session and marks slot as occupied.
   * Response (example):

     * `{ "session_id": 1, "plate": "ABC123", "slot_code": "A01", "check_in_at": "..." }`

4. `POST /exits`

   * Registers vehicle exit and calculates payment.
   * Request body:

     * `{ "plate": "ABC123" }`
   * Behavior:

     * Finds active session.
     * Calculates minutes between `check_in_at` and current time.

       * Minimum 1 minute.
     * `amount = minutes * rate_per_minute` (from active tariff).
     * Marks session as closed and frees slot.
   * Response (example):

     * `{ "session_id": 1, "plate": "ABC123", "minutes": 37, "amount": 1.85, ... }`

5. `GET /sessions?limit=N`

   * Lists recent parking sessions.
   * Used for “Recent activity” / audit tables.

6. `GET /stats/overview`

   * Returns aggregated data for dashboard:

     * `occupied` — total occupied slots
     * `free` — total free slots
     * `activeVehicles` — vehicles currently inside
     * `currentRatePerMinute` — active tariff
     * `occupancyPercent` — occupied / total * 100

(Additional report endpoints can be added in `routes_reports.py` and `report_service.py`.)

---

8. Architecture & Design Notes

---

* **Separation of concerns**

  * API layer (`app/api`):

    * Validates HTTP input.
    * Maps requests/responses to service calls.
    * No business rules inside routes.
  * Service layer (`app/services`):

    * Core business logic:

      * ParkingService: entries, exits, sessions, overview.
      * SlotService, TariffService, ReportService.
    * Testable, independent from HTTP.
  * Repository layer (`app/repositories`):

    * All direct SQLAlchemy queries are concentrated here.
    * Each repository works with a specific model.
  * Models (`app/models.py`):

    * Persistence entities (SQLAlchemy).
  * Schemas (`app/schemas.py`):

    * DTOs / contracts exposed by the API.

* **SOLID-oriented**

  * Single Responsibility:

    * Each service and repository has one focus.
  * Open/Closed:

    * New reports/endpoints can be added without breaking existing ones.
  * Dependency Inversion:

    * Routes depend on service interfaces, services on repositories, not on framework details.
  * Clear testing boundaries via dependency injection (FastAPI’s `Depends`).

* **Auth Integration**

  * Core service does NOT implement user management.
  * Exposes hooks via `auth_service.py` and dependencies in `deps.py`:

    * When `DISABLE_AUTH=false`, every request must include `Authorization: Bearer <jwt>`.
    * Token validation is delegated to the AUTH-SERVICE or shared JWT secret/public key.
  * This keeps auth concerns separated and aligned with microservice boundaries.

---

9. Integration with WEB UI

---

* The WEB UI should consume this service via:

  * `GET /api/core/stats/overview` — dashboard cards
  * `GET /api/core/sessions` — recent activity table
  * `GET /api/core/slots` — slots table
  * `POST /api/core/entries` — register entry form
  * `POST /api/core/exits` — register exit form

* During development:

  * Use `DISABLE_AUTH=true` and a fixed `Authorization: Bearer demo-token` header from the frontend.

* In production:

  * Enable auth, obtain real JWT from AUTH-SERVICE, and forward it in each request.

---

10. Notes for Instructors / Reviewers

---

* All core business rules for the workshop are inside this module.
* Tests demonstrate:

  * Clean separation of layers.
  * Deterministic behavior for key flows (entry, exit, stats).
* The structure is intentionally simple but professional:

  * Easy to extend with:

    * More detailed pricing rules.
    * Multi-parking support.
    * Advanced reports.
    * Real authentication and roles.

End of README.